<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Gesture Snake</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; transform: scaleX(-1); /* 镜像翻转 */ }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .text-overlay { position: absolute; color: white; text-shadow: 1px 1px 2px black; font-weight: bold; }
        #start-btn { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 15px 30px; font-size: 20px; background: #00ff00; border: none; border-radius: 10px;
            pointer-events: auto; cursor: pointer; z-index: 20;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="input_video" style="display:none" autoplay playsinline webkit-playsinline muted></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="ui-layer">
        <div class="text-overlay" style="top: 20px; left: 20px; font-size: 24px;" id="score-board">Score: 0</div>
        <div class="text-overlay" style="bottom: 20px; left: 20px; font-size: 16px;" id="status-text">Loading Model...</div>
    </div>

    <button id="start-btn" onclick="startGame()">Tap to Start</button>

   <script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const scoreBoard = document.getElementById('score-board');
    const statusText = document.getElementById('status-text');
    const startBtn = document.getElementById('start-btn');

    let isPlaying = false;
    let score = 0;
    let width = window.innerWidth;
    let height = window.innerHeight;
    
    // 游戏参数
    let snakeBody = [];
    const initialLength = 15;
    const snakeRadius = 15;
    const speed = 5; 
    let food = {x: 0, y: 0, r: 15, color: '#ffcc00'};
    let targetPos = {x: width/2, y: height/2};
    let particles = [];
    
    // 强制设置 Canvas 大小与屏幕一致
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvasElement.width = width;
        canvasElement.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- MediaPipe 设置 ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, // 【关键修改】手机端改成 0 (Lite模型)，速度更快，不容易卡顿
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    // 【核心修复】将游戏渲染逻辑完全放入 MediaPipe 的回调中
    // 确保顺序永远是：1.清空 -> 2.画视频背景 -> 3.画蛇 -> 4.显示
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,  // 降低分辨率以提升手机性能
        height: 480,
        facingMode: 'user'
    });

    function startGame() {
        startBtn.style.display = 'none';
        statusText.innerText = "Initializing...";
        camera.start()
            .then(() => {
                resetGame();
                isPlaying = true;
                statusText.innerText = "Show Hand to Play";
                // 注意：这里不再单独启动 loop()，完全依赖 camera 驱动
            })
            .catch(err => {
                alert("Camera Error: " + err);
            });
    }

    function resetGame() {
        snakeBody = [];
        // 初始化蛇身
        for(let i=0; i<initialLength; i++) {
            snakeBody.push({x: width/2, y: height/2 + i*5});
        }
        score = 0;
        spawnFood();
    }

    function spawnFood() {
        food.x = Math.random() * (width - 60) + 30;
        food.y = Math.random() * (height - 60) + 30;
    }

    // 这是一帧内所有的逻辑，保证图层顺序正确
    function onResults(results) {
        // 1. 绘制背景 (摄像头画面)
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
        
        // 2. 更新手势目标点
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            // 获取食指指尖 (索引 8)
            // 镜像处理：手机前置摄像头是镜像的
            const x = landmarks[8].x * width;
            const y = landmarks[8].y * height;
            targetPos.x = x;
            targetPos.y = y;
            
            // 画个小圆圈提示手在哪里
            drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
        }

        // 3. 如果游戏开始了，更新并绘制游戏元素
        if (isPlaying) {
            updateGameLogic(); // 算位置
            drawGameElements(); // 画出来
        }
        
        canvasCtx.restore();
    }

    function updateGameLogic() {
        // 移动蛇头逻辑
        let head = snakeBody[0];
        // 如果没有检测到手，蛇就慢慢停下或者保持惯性，这里简单处理为向目标点移动
        let dx = targetPos.x - head.x;
        let dy = targetPos.y - head.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        let newHead = {x: head.x, y: head.y};

        if (dist > speed) {
            newHead.x += (dx / dist) * speed;
            newHead.y += (dy / dist) * speed;
        } else {
            newHead.x += dx * 0.2;
            newHead.y += dy * 0.2;
        }

        snakeBody.unshift(newHead);

        // 吃食物
        let distFood = Math.sqrt((newHead.x - food.x)**2 + (newHead.y - food.y)**2);
        if (distFood < (snakeRadius + food.r)) {
            score += 10;
            scoreBoard.innerText = "Score: " + score;
            spawnFood();
            // 粒子特效
            for(let k=0; k<8; k++) {
                particles.push({
                    x: food.x, y: food.y,
                    vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
                    life: 20, color: `hsl(${Math.random()*360}, 100%, 50%)`
                });
            }
        } else {
            snakeBody.pop();
        }

        // 粒子更新
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if(p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawGameElements() {
        // 画食物
        canvasCtx.beginPath();
        canvasCtx.arc(food.x, food.y, food.r, 0, 2 * Math.PI);
        canvasCtx.fillStyle = food.color;
        canvasCtx.fill();
        canvasCtx.strokeStyle = "white";
        canvasCtx.stroke();

        // 画蛇
        for (let i = snakeBody.length - 1; i >= 0; i--) {
            let segment = snakeBody[i];
            canvasCtx.beginPath();
            // 简单的渐变色
            canvasCtx.fillStyle = `hsl(${(score + i*5)%360}, 70%, 50%)`;
            canvasCtx.arc(segment.x, segment.y, snakeRadius, 0, 2 * Math.PI);
            canvasCtx.fill();
        }

        // 画粒子
        for (let p of particles) {
            canvasCtx.beginPath();
            canvasCtx.fillStyle = p.color;
            canvasCtx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
            canvasCtx.fill();
        }
    }
</script>
</body>
</html>



