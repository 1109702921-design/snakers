<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Gesture Snake</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: Arial, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; transform: scaleX(-1); /* 镜像翻转 */ }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .text-overlay { position: absolute; color: white; text-shadow: 1px 1px 2px black; font-weight: bold; }
        #start-btn { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 15px 30px; font-size: 20px; background: #00ff00; border: none; border-radius: 10px;
            pointer-events: auto; cursor: pointer; z-index: 20;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <video id="input_video" style="display:none"></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="ui-layer">
        <div class="text-overlay" style="top: 20px; left: 20px; font-size: 24px;" id="score-board">Score: 0</div>
        <div class="text-overlay" style="bottom: 20px; left: 20px; font-size: 16px;" id="status-text">Loading Model...</div>
    </div>

    <button id="start-btn" onclick="startGame()">Tap to Start</button>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const scoreBoard = document.getElementById('score-board');
        const statusText = document.getElementById('status-text');
        const startBtn = document.getElementById('start-btn');

        let isPlaying = false;
        let score = 0;
        let width = window.innerWidth;
        let height = window.innerHeight;
        
        // 游戏参数
        let snakeBody = [];
        const initialLength = 15;
        const snakeRadius = 15;
        const speed = 5; // 移动速度
        let food = {x: 0, y: 0, r: 15, color: '#ffcc00'};
        let targetPos = {x: width/2, y: height/2};
        let particles = [];

        // 初始化 Canvas 大小
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvasElement.width = width;
            canvasElement.height = height;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- MediaPipe 设置 ---
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults(onResults);

        // --- 摄像头设置 ---
        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720,
            facingMode: 'user' // 使用前置摄像头
        });

        function startGame() {
            startBtn.style.display = 'none';
            statusText.innerText = "Initializing Camera...";
            camera.start()
                .then(() => {
                    resetGame();
                    isPlaying = true;
                    statusText.innerText = "Show Hand to Play";
                    loop();
                })
                .catch(err => {
                    alert("Camera access denied or error: " + err);
                });
        }

        // --- 游戏逻辑 ---

        function resetGame() {
            snakeBody = [];
            for(let i=0; i<initialLength; i++) {
                snakeBody.push({x: width/2, y: height/2});
            }
            score = 0;
            spawnFood();
        }

        function spawnFood() {
            food.x = Math.random() * (width - 40) + 20;
            food.y = Math.random() * (height - 40) + 20;
        }

        function onResults(results) {
            // 绘制背景 (摄像头画面)
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            
            // 手势识别
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                // 获取食指指尖 (索引 8)
                // 注意：Canvas是镜像的，所以 X 坐标逻辑要反一下
                const x = (1 - landmarks[8].x) * width; 
                const y = landmarks[8].y * height;
                
                targetPos.x = x;
                targetPos.y = y;

                // 画手部骨架 (可选)
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
            }
            canvasCtx.restore();
        }

        function updateGame() {
            if (!isPlaying) return;

            // 移动蛇头逻辑 (向量)
            let head = snakeBody[0];
            let dx = targetPos.x - head.x;
            let dy = targetPos.y - head.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            let newHead = {x: head.x, y: head.y};

            if (dist > speed) {
                newHead.x += (dx / dist) * speed;
                newHead.y += (dy / dist) * speed;
            } else {
                newHead.x += dx * 0.5; // 靠近时减速吸附
                newHead.y += dy * 0.5;
            }

            snakeBody.unshift(newHead);

            // 吃食物判定
            let distFood = Math.sqrt((newHead.x - food.x)**2 + (newHead.y - food.y)**2);
            if (distFood < (snakeRadius + food.r)) {
                score += 10;
                scoreBoard.innerText = "Score: " + score;
                spawnFood();
                // 简单的粒子特效
                for(let k=0; k<5; k++) {
                    particles.push({
                        x: food.x, y: food.y,
                        vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                        life: 20, color: `hsl(${Math.random()*360}, 100%, 50%)`
                    });
                }
            } else {
                snakeBody.pop();
            }

            // 粒子更新
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if(p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawGame() {
            // 画食物
            canvasCtx.beginPath();
            canvasCtx.arc(food.x, food.y, food.r, 0, 2 * Math.PI);
            canvasCtx.fillStyle = food.color;
            canvasCtx.fill();
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = "white";
            canvasCtx.stroke();

            // 画蛇
            for (let i = snakeBody.length - 1; i >= 0; i--) {
                let segment = snakeBody[i];
                canvasCtx.beginPath();
                canvasCtx.arc(segment.x, segment.y, snakeRadius - (i>10?5:0), 0, 2 * Math.PI);
                // 彩虹色
                canvasCtx.fillStyle = `hsl(${(score + i*5)%360}, 70%, 50%)`;
                canvasCtx.fill();
            }

            // 画粒子
            for (let p of particles) {
                canvasCtx.beginPath();
                canvasCtx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                canvasCtx.fillStyle = p.color;
                canvasCtx.fill();
            }
            
            // 画目标点提示
            canvasCtx.beginPath();
            canvasCtx.arc(targetPos.x, targetPos.y, 8, 0, 2 * Math.PI);
            canvasCtx.fillStyle = "rgba(255, 255, 255, 0.5)";
            canvasCtx.fill();
        }

        function loop() {
            updateGame();
            drawGame();
            requestAnimationFrame(loop);
        }
    </script>
</body>
</html>
